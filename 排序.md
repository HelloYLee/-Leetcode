# 排序

最近刷到排序和链表的题，以前学的基本又忘差不多了，再来加强


| 算法 | 平均时间 | 最好时间 |  最坏时间 |  空间 |  稳定性 |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 冒泡排序 | O(n*n) | O(n）| O(n*n) | O(1) | 稳定
| 选择排序 | O(n*n) | O(n*n）| O(n*n) | O(1) | 不稳定
| 插入排序 | O(n*n) | O(n）| O(n*n) | O(1) | 稳定
| 希尔排序 |O(nlogn) | O(nlog^2n) | O(nlog^2n) | O(1) | 不稳定
| 归并排序 |O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定
| 快速排序 |O(nlogn) | O(nlogn) | O(n*n)  | O(logn) | 不稳定
| 堆排序 |O(nlogn) | O(nlogn) | O(nlogn)  | O(1) | 不稳定

实例： 对数组[4, 3, 1, 6, 9, 0]进行排序

## 冒泡排序
目前最熟悉的一个排序方法了，也是所有里面最好理解的。冒泡排序就是重复比较两个相邻的元素，如果排在前面的数较大，则交换两个元素的顺序，随着排序的进行，较大的数逐渐移到数组的后面，感觉就像是在冒泡一样。这也是这个名称的由来，比较形象。

Go 实现:
```sh
func sort(input []int) []int {
	for i := 0; i < len(input)-1; i++ {
		for j := i + 1; j < len(input); j++ {
			if input[i] > input[j] {
				input[i], input[j] = input[j], input[i]
			}
		}
	}
	return input
}
```

## 选择排序
循环N次，每次从数组起始位置开始，找到最小的数据，放到数组的最前面。第一次循环，获得最小的数据；第二次循环，获得第二小的数据....以此类推
Go 实现:
```sh
for i := 0; i < len(input)-1; i++ {
		minIndex := i
		for j := i + 1; j < len(input); j++ {
			if input[j] < input[minIndex] {
				// 记录最小值的位置
				minIndex = j
			}
		}
		// 将最小值移到前面
		input[i], input[minIndex] = input[minIndex], input[i]
	}
	return input
}
```
## 插入排序
将第一个元素看成一个有序数组，从第二个元素开始，将所有元素按照顺序插入到有序数组中去
go实现
```
	for i := 1; i < len(input); i++ {
		temp := input[i]
		// 从后往前遍历有序数组，找到第一个小于当前值的位置
		var j = i
		for ; j > 0 && input[j-1] > temp; j-- {
			// 有序数组往后移动一位
			input[j] = input[j-1]
		}
		// 将当前值temp插入
		input[j] = temp
	}
	return input
```
## 希尔排序

## 归并排序

## 快速排序

## 堆排序

